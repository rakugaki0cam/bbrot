#   bbrot.py
#                   v2
#
#       2022.07.09


import math
from webbrowser import BackgroundBrowser
import numpy as np
import cv2
import os
import matplotlib.pyplot as plt
from PIL import Image
import sys
sys.path.append('/path/to/dir')
import pyocr
import pyocr.builders

#ウインドウの設定
cv2.namedWindow('template3', cv2.WINDOW_NORMAL)
cv2.moveWindow('template3', 0, 200)

cv2.namedWindow('match BB', cv2.WINDOW_NORMAL)
cv2.moveWindow('match BB', 200, 200)

#色の設定
mazenta = (255, 0, 255)
yellow  = (0, 255, 255)
green   = (0, 255, 0)
darkGreen = (0, 127, 0)
white   = (255, 255, 255)


def crop(image, pt, size):
    """
    画像の一部を矩形で切り取る
    
    Parameters
    ----------
    image : mat
        切り出し元の画像
    pt : [number, number]
        切り取り中心[col, row]
    size : [number, number]
        切り取りサイズ[width, height]

    Returns
    -------
    切り出した画像
    """
    left = int(pt[0] - size[0] / 2)
    if left < 0:
        left = 0      
    right = int(pt[0] + size[0] / 2)
    top = int(pt[1] - size[1] / 2)
    if top < 0:
        top = 0
    bottom = int(pt[1] + size[1] / 2)
    d = len(image.shape)
    if d <= 2:
        #grayscale
        return image[top:bottom, left:right]
    else:
        #color
        return image[top:bottom, left:right, :]


def rot(image, rot_in_deg):
    """
    画像を画像中央を中心に回転させる。回転により生じる背景は白で塗りつぶし。
    
    Parameters
    ----------
    image : mat
        元画像
    rot_in_deg : float
        回転角度(deg)
    Returns
    -------
    回転した画像
    """
    (h, w) = (0, 0)
    if(len(image.shape)):
        #gray scale
        (h, w) = image.shape
        bg = 255
    else:
        #color
        (h, w) = image.shape[:2]
        bg = (255, 255, 255)
    center = (w / 2.0, h / 2.0)
    mat = cv2.getRotationMatrix2D(center, rot_in_deg, scale = 1.0)  #回転のための変換行列を生成
    return cv2.warpAffine(image, mat, (w, h), borderValue = bg)     #アフィン変換


def mask_circle(image, radius):
    """
    円の外側を白で塗りつぶす。

    Parameters
    ----------
    image : mat
        塗りつぶし対象の画像

    radius : int
        円の半径(px)
    Returns
    -------
    塗りつぶした画像
    """
    mask = np.zeros(image.shape, np.uint8)
    center = (int(mask.shape[0]/2), int(mask.shape[1]/2))
    cv2.circle(mask, center, radius, 1, -1)
    ret = image * mask
    bg = np.ones(image.shape, np.uint8) * 255
    cv2.circle(bg, center, radius, 0, -1)
    return ret + bg


def estimate_rot(image, template, pt, size):
    """
    回転角の推定

    Parameters
    ----------
    image : mat
        推定対象の画像
    template : mat
        テンプレート画像
    pt : [number, number]
        推定対象の中心位置[col,row]
    size : any
        比較するBB画像の直径 px    
    Returns
    -------
    回転角 -180~+180(deg)
    """
    angle = -1
    max = 1
    ext = 0    #周りを少し広く
    cr = crop(image, pt, (size + ext, size + ext ))
    cv2.imshow("match BB", cr)
    (w, h) = template.shape[: : -1] 

    #### whole test #####
    '''
    img2 = image.copy()
    matchResult = cv2.matchTemplate(img2, template, cv2.TM_CCOEFF)
    _, maxVal, _, maxLoc = cv2.minMaxLoc(matchResult)   ###minVal,maxVal,minIndex,maxIndex
    topLeft = maxLoc
    bottomRight = (topLeft[0] + w, topLeft[1] + h)
    cv2.rectangle(img2, topLeft, bottomRight, (255, 0, 255), 3)
    #マッチリザルト
    plt.subplot(121),plt.imshow(matchResult, cmap = 'gray')
    plt.title('Matching Result'), plt.xticks([]), plt.yticks([])
    plt.subplot(122),plt.imshow(img2, cmap = 'gray')
    plt.title('Detected Point'), plt.xticks([]), plt.yticks([])
    plt.show()
    #うまくいかない
    '''
    #######################


    # ぐるぐる回しながら相関が最大となる角度を求める
    for i in range(-180, 180):
        tp = rot(template, i)
        matchResult = cv2.matchTemplate(cr, tp, cv2.TM_CCOEFF)
        _, maxVal, _, maxLoc = cv2.minMaxLoc(matchResult)   ###minVal,maxVal,minIndex,maxIndex
        
        if(maxVal > max):
            cr2 = cr.copy()
            max = maxVal
            angle = i
            #角度表示
            cv2.putText(tp, str(i), org = (0, 15), fontFace = cv2.FONT_HERSHEY_SIMPLEX, fontScale = 0.4, color = 0, thickness = 1)
            # org は左下の座標
            #マッチ値表示
            cv2.putText(tp, str(int(max)), org = (0, 100), fontFace = cv2.FONT_HERSHEY_SIMPLEX, fontScale = 0.4, color = 0, thickness = 1)
            topLeft = maxLoc
            bottomRight = (topLeft[0] + w, topLeft[1] + h)
            cv2.rectangle(cr2, topLeft, bottomRight, (255, 0, 255), 1)
            
            cv2.imshow("match BB", cr2)
            cv2.imshow("template3", tp)
            cv2.waitKey(1)

            #マッチ　類似度のヒートマップ
            #fig, ax = plt.subplots(figsize=(10, 5))
            #im = ax.imshow(matchResult, cmap="jet")
            #plt.show()
            

    print(angle , '° Match value:' ,max)
    return angle

    
def winShow(image, name, pt, size):
    """
    画像をウインドウで表示
    Parameters
    ----------
    image : mat
        画像データ
    name : string
        ウインドウ名
    pt : [number, number]
        ウインドウ表示位置[col, row]pixel
    size : [number, number]
        ウインドウに表示する画像サイズ[width, height]pixel
    Returns
    -------
    なし
    """
    cv2.namedWindow(name, cv2.WINDOW_NORMAL)
    cv2.imshow(name, image)
    cv2.moveWindow(name, pt[0], pt[1])
    cv2.resizeWindow(name, size[0], size[1])
    return



def process(filename):
    """
    写っているすべてのBB弾の角度を推定
    Parameters
    ----------
    filename : string
        画像ファイル名

    Returns
    -------
    結果をオーバーレイした画像
    """

    src = cv2.imread(filename)
    #グレースケール化(OCRで使用)
    src = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)
    #高さを中央付近300pxにクロップ
    w = src.shape[1]
    h = 300
    top = (src.shape[0] - h) // 2
    flip = src[top: top + h, 0: w-400] # 0: w] ###############スタート付近の白帯をカット（撮影失敗）
    #右から撃っているので、左から右への時系列になるように左右反転
    flip = cv2.flip(flip, 1)      # =0:上下反転、>0:左右反転、 <0:上下左右反転
    #コントラスト調整 (テンプレートマッチングで使用)
    scaled = cv2.convertScaleAbs(flip, alpha = 3.5, beta = 0)    #alpha:スケールファクタ1.0〜2.0 beta:加算値
    #ノイズ除去し、2値化してブロブ検出用の画像を作成
    median = cv2.medianBlur(flip, ksize = 3)  #5
    #ヒストグラム
    hist1 = cv2.calcHist(flip, channels = [0], mask = None, histSize = [256], ranges = [0,256])
    hist2 = cv2.calcHist(scaled, channels = [0], mask = None, histSize = [256], ranges = [0,256])
    #平坦化
    clahe = cv2.createCLAHE(clipLimit = 2.0, tileGridSize = (8,8))
    cl1 = clahe.apply(flip)
    hist3 = cv2.calcHist(cl1, channels = [0], mask = None, histSize = [256], ranges = [0,256])


    # BB弾検出の閾値(DN)
    min_gray = 35  #30
    max_gray = 255
    ret, threshold = cv2.threshold(median, min_gray, max_gray, cv2.THRESH_BINARY_INV)
    src2 = threshold.copy()    #二値データ
    #大津の手法
    ret2, threshold2 = cv2.threshold(median, min_gray, max_gray, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
    src3 = threshold2.copy()    #二値データ

    hw = 300
    hwd = 110
    winShow(flip, 'flip', (700, hw), (w // 4, h // 4))  #1/4に縮小
    winShow(scaled, 'scaled', (700, hw + hwd), (w // 4, h // 4))
    winShow(median, 'median', (700, hw + hwd + hwd), (w // 4, h // 4))
    winShow(threshold, 'threshold', (700, hw + hwd + hwd + hwd), (w // 4, h // 4))
    winShow(cl1, 'CLAHE', (700, hw + hwd + hwd + hwd + hwd), (w // 4, h // 4))
    winShow(threshold2, 'threshold2', (700, hw + hwd + hwd + hwd + hwd + hwd), (w // 4, h // 4))
    print('OHTU th = ',ret2)

    plt.plot(hist1)  #ヒストグラム
    plt.plot(hist2)  #ヒストグラム
    plt.plot(hist3)  #ヒストグラム
    plt.show()

    #ブロブ（塊）検出の設定
    params = cv2.SimpleBlobDetector_Params()
    #閾値
    params.minThreshold = min_gray  ###
    params.maxThreshold = max_gray  ###
    #塊の大きさ（面積）
    params.filterByArea = True
    bbDia = 143      #BB弾の半径(px)###########120
    minDia = 20
    maxDia = 10
    params.minArea = (bbDia - minDia) ** 2 * math.pi / 4 * 0.75
    params.maxArea = (bbDia + maxDia) ** 2 * math.pi / 4
    #円形度でフィルタ(凹面concave)
    params.filterByCircularity = True
    params.minCircularity = 0.4     #0〜1 = 4πS/L^2   S:面積(画素数) L:周囲長　　　円形度が高い->1.0
    ###模様が外周にかかって輪郭が切れた時に凹面になるので小さめの値にする
    #凸面フィルタ
    params.filterByConvexity = True
    params.minConvexity = 0.5       #0〜1 = S/C  S:面積　C:凸面の面積（円形から出っぱった分）
    #楕円形フィルタ（形態の伸び　円形=1、直線=0 慣性モーメント）
    params.filterByInertia = True
    params.minInertiaRatio = 0.5
    #検出器を設定
    ver = (cv2.__version__).split('.')
    if int(ver[0]) <= 2:
        #openCV ver.2
        detector = cv2.SimpleBlobDetector(params)
    else:
        #openCV ver.3~
        detector = cv2.SimpleBlobDetector_create(params)  

    #検出器を作動（ブロブを検出する）
    keypoints = detector.detect(src2) 

    #ブロブを円形で表示
    blank = np.zeros((1, 1))  
    blobs = cv2.drawKeypoints(flip, keypoints, blank, green, cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS) 
    #ブロブの個数
    bbcount = len(keypoints)
    print(f'円の個数: {bbcount}')
    winShow(blobs, filename, (700, 190), (w // 4, h // 4))  #1/4に縮小

    #ブロブ検出数の判定
    if bbcount < 10:
        print('検出数不足   any key to go')
        cv2.waitKey(0)
        return blobs    #円検出だけの画像

    #途中が抜けた時の処理ーーー未定

    ######画像変換の様子だけ見たい時##############
    #cv2.waitKey(0)
    #return -1 ################

    #### OCR #####   
    ocrLcd(src)
    #周期の入力
    dt = float(input('1コマの周期 usec = '))

    #座標x位置順でソート
    kps = sorted(keypoints, key=lambda kp: kp.pt[0])    #kp.pt[0]:x座標
    bbcenter = []
    blobsize = []
    for k in kps:          ###test
        center = (int(k.pt[0]), int(k.pt[1]))
        #ブロブの中心を表示
        cv2.drawMarker(blobs, center, darkGreen, markerType = cv2.MARKER_CROSS, markerSize = 300)
        bbcenter.append(center)
        blobsize.append(int(k.size))

    #BB進行軸線の傾斜角度
    dY = bbcenter[len(bbcenter) - 1][1] - bbcenter[0][1]
    dX = bbcenter[len(bbcenter) - 1][0] - bbcenter[0][0]
    incAngle = -math.degrees(math.atan(dY / dX))   #下向きをマイナス表示

    print('center', bbcenter)
    print('size', blobsize)
    print('inclination angle: {}/{} = {:6.3f}deg'.format(dY, dX, incAngle))

    #画像へコマ周期、初速、ファイル名を書き込み
    v0 = 0.012 / (dt / 1000000) 
    text = "Circular Blobs:{:2d}  dt:{:5.1f}usec  v0:{:5.1f}m/sec  incline:{:6.3f}deg  ({})".format(len(keypoints), dt, v0, incAngle, filename)
    locate = (int(kps[0].pt[0] - 100), int(kps[0].pt[1] + 100))
    cv2.putText(blobs, text, locate, cv2.FONT_HERSHEY_SIMPLEX, 0.8, white, 1)


    #ブロブ検出結果から作業用画像をクロップする  #########################################
    #x座標
    offsetX = 250
    left = bbcenter[0][0] - offsetX
    if left < 0:
        left = 0
    right = bbcenter[bbcount - 1][0] + offsetX
    if right > blobs.shape[1]:              #(y_size, x_size, color)
        right = blobs.shape[1]

    #y座標
    offsetY = 25
    bby = sorted(bbcenter, key = lambda x: x[1])
    top = bby[bbcount - 1][1] - blobsize[0] - offsetY
    if top < 0:
        top = 0
    bottom = bby[0][1]  + blobsize[0] + offsetY  #(y_size, x_size, color)
    if bottom > blobs.shape[0]:     
        bottom = blobs.shape[0]

    #ブロブ検出＆作業書き込み用画像をクロップ
    d = len(blobs.shape)
    if d <= 2:
        blobs =  blobs[top:bottom, left:right]
    else:
        blobs = blobs[top:bottom, left:right, :]
    #マッチ検出用画像もクロップ
    d = len(scaled.shape)
    if d <= 2:
        scaled =  scaled[top:bottom, left:right]
    else:
        scaled = scaled[top:bottom, left:right, :]
    #median画像もクロップ
    d = len(median.shape)
    if d <= 2:
        median =  median[top:bottom, left:right]
    else:
        median = median[top:bottom, left:right, :]

    cv2.imshow("blobs", blobs) 
    cv2.imshow('scaled', scaled)
    cv2.imshow('median', median)
    cv2.waitKey(1)

    #クロップ後の座標修正
    bbcenter2 = []
    for b in bbcenter:
        bbcenter2.append((b[0] - left, b[1] - top))

    #左から数えてtemplate_index目のBB弾を基準とする
    #カメラ撮影光軸中心付近
    template_index = bbcount // 2   #//の答えは整数となる

    #基準としたBB弾を切り出してテンプレートとする
    c = crop(scaled, bbcenter2[template_index], (blobsize[template_index], blobsize[template_index]))
    #周辺の影の部分をマスク
    mask = int((kps[template_index].size / 2) - 8)#######-5 -> -8
    template = mask_circle(c, mask)
    center = (int(template.shape[0] / 2), int(template.shape[1] / 2))
    template = crop(template, center, (mask * 2, mask * 2))
    #2値化オプション??###
    ret, template = cv2.threshold(template, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU) 


    print('計算開始')

    #検出したBB弾すべてに角度推定を実行する
    result = []
    anglefirst = 999
    for k in range(bbcount):
        point = bbcenter2[k] #BB中心
        #回転角度を解析
        angle = estimate_rot(scaled, template, point, blobsize[k]) ########scaled

        #回転角がひっくり返っている時の処理　ーーー未定


        #回転角度の線を表示
        line = 80
        rad = math.radians(angle)
        dl = (math.cos(rad) * line, -math.sin(rad) * line)
        pt1 = np.add     (point, dl).astype(np.int32)
        pt2 = np.subtract(point, dl).astype(np.int32)
        cv2.line(blobs, pt1, pt2, mazenta, thickness = 1)
        
        if anglefirst == 999:
            anglefirst = angle
            angleBefore = angle

        #角度の書き込み
        da = angle - angleBefore
        angleTotal = angle - anglefirst
        angleBefore = angle

        textAngle = '{:4d}deg'.format(angle)
        cv2.putText(blobs, textAngle, org = (point[0] + 30, point[1] - 60), fontFace = cv2.FONT_HERSHEY_SIMPLEX, fontScale = 0.8, color = mazenta, thickness = 1)
        if k >= 1:
            textDa = '({:3d})'.format(da)
            cv2.putText(blobs, textDa, org = (point[0] + 65, point[1] - 30), fontFace = cv2.FONT_HERSHEY_SIMPLEX, fontScale = 0.8, color = yellow, thickness = 1)

        #回転角の書き込み
        if k >= template_index:
            try:
                kaiten = 1000000.0 / dt /(k * 360 / angleTotal)
                textRps =  '{:6.1f}rps'.format (kaiten)
                cv2.putText(blobs, textRps, org = (point[0] + 0, point[1] + 90), fontFace = cv2.FONT_HERSHEY_SIMPLEX, fontScale = 0.8, color = white, thickness = 1)
            except ZeroDivisionError:
                kaiten = 0
        result.append((k, point[0], point[1], blobsize[k], angle, da, angleTotal))

        cv2.imshow("blobs", blobs) 
        cv2.waitKey(1) 

    # 結果の表示など
    for i, d in enumerate(result):
        print(*d, sep = ',')
    
    # コマ数と回転角
    for r in result[template_index: ]:
        koma = r[0]
        try:
            kaiten = 1000000.0 / dt /(r[0] * 360 / r[6])
        except ZeroDivisionError:
            kaiten = 0    
        print('{:2d}コマ {:6.1f}rps'.format(koma, kaiten))
    return blobs


def ocrLcd(image):
    #OCRで発光周期時間を読み取り
    #
    #lcdImage = crop(image, ( 1800, 800) , ( 1000, 1000)) 
    #lcdImage = cv2.convertScaleAbs(lcdImage, alpha = 0.5, beta = -20)
    #lcdImage = cv2.medianBlur(lcdImage, ksize = 1) #ksizeは奇数
    #ret, lcdImage = cv2.threshold(lcdImage, 95, 255,cv2.THRESH_BINARY)

    # 20200717 P110170~
    lcdImage = crop(image, ( 2300, 3000) , ( 1000, 1000))  
    lcdImage = cv2.convertScaleAbs(lcdImage, alpha = 0.5, beta = -20)
    lcdImage = cv2.medianBlur(lcdImage, ksize = 1) #ksizeは奇数
    ret, lcdImage = cv2.threshold(lcdImage, 100, 255,cv2.THRESH_BINARY)
    #retはOTSUのときのしきい値
    kernel = np.ones((3,3),np.uint8)
    lcdImage = cv2.erode(lcdImage, kernel,3)

    #lcdImage = rot(lcdImage, 91.5)
    lcdImage = rot(lcdImage, -90)
    #cv2.imshow("image4", lcdImage)
    #cv2.waitKey(1) 
    lcdImage = cv2.bitwise_not(lcdImage)    #反転
    #cv2.imshow("image4", lcdImage)
    #cv2.waitKey(1) 

    #####test 文字
    cv2.putText(lcdImage, "* test 12.3m/sec (456.7us) test *", org = (20, 860), fontFace = cv2.FONT_HERSHEY_SIMPLEX, fontScale = 1.0, color = (0,0,0), thickness = 2)
    cv2.imwrite('test.png', lcdImage)

    cv2.namedWindow("lcdImage", cv2.WINDOW_NORMAL)
    h = lcdImage.shape[0]
    w = lcdImage.shape[1]
    rLcdImage = cv2.resize(lcdImage, (w // 2, h // 2))

    cv2.imshow("lcdImage", rLcdImage)
    cv2.moveWindow("lcdImage", 0, 500)

    #cv2.imwrite("test.png",lcdImage)
    cv2.waitKey(1) 
    
    tools = pyocr.get_available_tools()
    if len(tools) == 0:
        #print("No OCR tool found")
        SystemExit(1)

    tool = tools[0]
    #print("will use tool '%s'" % (tool.get_name()))
    langs = tool.get_available_languages()
    #print("available languages: %s" % ", ".join(langs))

    #builder = pyocr.builders.TextBuilder(tesseract_layout =  6) #text
    builder = pyocr.builders.WordBoxBuilder(tesseract_layout=6) #box
    txt = tool.image_to_string(Image.open('test.png'), lang = 'eng', builder = builder)
    
    out = cv2.imread('test.png')
    for r in txt:
        print(r.content, end = ' ')
        #print(r.position)
        cv2.rectangle(out, r.position[0], r.position[1],(255, 0, 255), 2)

    cv2.imshow('lcdImage', out)
    cv2.waitKey(1)
    #print(txt)
    print()

    return txt



####  main  ######
#指定したフォルダの画像すべてに対して実行

root = './bbpict/go'
files = os.listdir(path = root)
filesSorted = sorted(files)
filesSorted.remove('.DS_Store')

for f in filesSorted:
    openFileName = os.path.join(root, f)
    print()
    print(openFileName)
    res = process(openFileName)
    savedFileName = "result" + f
    cv2.imwrite(savedFileName, res)

print('Complete')
print('any key -> exit system')
cv2.waitKey(0)
